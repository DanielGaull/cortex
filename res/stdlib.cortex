module stdlib {
    extend<T: ty> span<T> {
        fn __indexGet(&this, index: usz): T {
            let boxThis = anon this;
            let boxedResult = corelib::spanIndexGetSingleAnonymous(boxThis, index);
            deanon<T> boxedResult
        }

        fn __indexSet(&mut this, index: usz, value: T): void {
            let boxThis = anon this;
            let boxValue = anon value;
            corelib::spanIndexAssignSingleAnonymous(boxThis, index, boxValue);
        }
    }

    module collections {
        fn newList<T>(): &mut List<T> {
            heap List<T> {
                items: [],
                len: 0,
                capacity: 0,
            }
        }

        struct List<T: ty> {
            _items: &mut span<T>,
            _len: usz,
            _capacity: usz,

            fn add(&mut this, item: T) {
                if this._len >= this._capacity {
                    // TODO: finish writing this
                    // Would be nice to have for loops first to help w/ copying values
                } else {
                    _items[this._len] = item;
                    this._len += 1;
                }
            }

            fn len(&this): usz {
                this._len
            }
            fn capacity(&this): usz {
                this._capacity
            }
        }
    }
}
