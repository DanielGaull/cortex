contract Iterator<T> {
    fn next(&mut this): T;
    fn hasNext(&this): bool;
}

struct ListWrapper<D> follows Iterator<D> {
    items: &mut List<D>,
    index: usz,

    fn next(&mut this): D {
        let result = this.items[this.index];
        this.index += 1;
        result
    }
    fn hasNext(&this): bool {
        this.index < this.items.len()
    }
}

contract MapFn<T, R> {
    fn map(&this, item: T): R;
}

struct AddMapFn follows MapFn<i32, i32> {
    value: i32,

    fn map(&this, item: i32): i32 {
        item + this.value
    }
}

fn mapper<T, R>(iter: follows Iterator<T>, function: follows MapFn<T, R>): &mut List<R> {
    let result: &mut List<R> = [];
    while iter.hasNext() {
        let item = function.map(iter.next());
        result.add(item);
    }
    result
}

contract AddTo<R, Out> {
    fn add(&this, other: R): Out;
}

struct BoxNumber follows MapFn<i32, i32> + AddTo<i32, i32> {
    value: i32,

    fn add(&this, other: i32): i32 {
        this.value + other
    }

    fn map(&this, item: i32): i32 {
        this.value - item
    }
}

struct Box<T> {
    item: T,

    fn get(&this): T {
        this.item
    }
    fn set(&mut this, value: T) {
        this.item = value;
    }
}

struct OtherListWrapper<D> {
    items: &mut List<D>,

    fn map<R>(&this, mapper: follows MapFn<D, R>): &mut List<R> {
        let result: &mut List<R> = [];
        let index = 0;
        while index < this.items.len() {
            result.add(mapper.map(this.items[index]));
            index += 1;
        }
        result
    }
}

struct IteratorMapper<T, R> {
    iter: follows Iterator<T>,
    mapper: follows MapFn<T, R>,

    fn map(&this): &mut List<R> {
        mapper(this.iter, this.mapper)
    }
}

contract Sizer {
    fn size(&this): i32;
}

contract SizerWrapper {
    fn size(&this, sz: follows Sizer): i32;
}

struct Square follows Sizer {
    len: i32,

    fn size(&this): i32 {
        this.len * this.len
    }
}

struct ConcreteShapeSizer follows SizerWrapper {
    fn size(&this, sz: follows Sizer): i32 {
        sz.size()
    }
}

contract MyAdd<T> {
    fn add(this, rhs: T): T;
}

extend i32 follows MyAdd<i32> {
    fn add(this, rhs: i32): i32 {
        this + rhs
    }
}

fn doAdd<T>(left: follows MyAdd<T>, right: T): T {
    left.add(right)
}
