module mylib {
    struct LibBox<T> {
        item: T,

        fn get(&this): T {
            this.item
        }

        fn set(&mut this, value: T) {
            this.item = value;
        }
    }

    fn getBox<T>(item: T): &mut LibBox<T> {
        heap LibBox<T> {
            item: item,
        }
    }

    fn readBox<T>(box: &LibBox<T>): T {
        box.get()
    }

    extend string {
        fn stringIdentity(this): string {
            this
        }
    }

    contract AFunc {
        fn a(&this, other: i32): i32;
    }

    struct NumWrapper follows AFunc {
        value: i32,

        fn a(&this, other: i32): i32 {
            this.value + other
        }
    }
}

module drawing {
    struct Point {
        coords: (i32, i32),

        fn getX(&this): i32 {
            this.coords.t0
        }

        fn getY(&this): i32 {
            this.coords.t1
        }
    }
}
